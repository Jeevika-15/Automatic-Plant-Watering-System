import tkinter as tk
from tkinter import ttk, messagebox
import threading
import queue
import time

# Optional serial support
USE_SERIAL = True        
SERIAL_PORT = "COM4"       
SERIAL_BAUD = 115200

if USE_SERIAL:
    try:
        import serial
    except Exception:
        print("pyserial is required for serial mode. Install with: pip install pyserial")
        raise

# ---------------- Serial Thread ----------------
class SerialThread(threading.Thread):
    def __init__(self, q, port, baud):
        super().__init__(daemon=True)
        self.q = q
        self.port = port
        self.baud = baud
        self.running = True
        self.ser = None
        self.connect()

    def connect(self):
        try:
            if self.port:
                self.ser = serial.Serial(self.port, self.baud, timeout=1)
                print(f"[Serial] Connected to {self.port} @ {self.baud}")
            else:
                self.ser = None
        except Exception as e:
            print(f"[Serial] Unable to open {self.port}: {e}")
            self.ser = None

    def run(self):
        # If serial not available -> mock data
        if self.ser is None:
            while self.running:
                mock_val = 2500 + int(800 * (0.5 - (time.time() % 1)))
                self.q.put(f"MOISTURE:{mock_val}")
                # mock pump state toggle occasionally
                if int(time.time()) % 15 == 0:
                    self.q.put("PUMP:ON")
                elif int(time.time()) % 15 == 8:
                    self.q.put("PUMP:OFF")
                time.sleep(1)
            return

        buf = b""
        while self.running:
            try:
                data = self.ser.read(128)
                if data:
                    buf += data
                    while b"\n" in buf:
                        line, buf = buf.split(b"\n", 1)
                        text = line.decode(errors="ignore").strip()
                        if text:
                            self.q.put(text)
                else:
                    time.sleep(0.05)
            except Exception as e:
                print("[Serial] read error:", e)
                time.sleep(1)

    def send(self, msg):
        if self.ser:
            try:
                self.ser.write((msg + "\n").encode())
            except Exception as e:
                print("[Serial] write error:", e)

    def stop(self):
        self.running = False
        if self.ser:
            try:
                self.ser.close()
            except:
                pass

# ---------------- Main GUI ----------------
class PlantApp:
    def __init__(self, root):
        self.root = root
        root.title("Plant Watering — Monitor & Control")
        root.geometry("720x540")
        root.resizable(False, False)

        # Queue & serial
        self.queue = queue.Queue()
        self.serial_thread = None

        # State variables
        self.current_moisture = tk.IntVar(value=0)
        self.pump_state = tk.StringVar(value="UNKNOWN")  # "ON", "OFF", "UNKNOWN"
        self.mode = tk.StringVar(value="AUTO")           # "AUTO" or "MANUAL"
        self.threshold = tk.IntVar(value=3000)
        self.connection_label = tk.StringVar(value="Not connected")

        # Animation state
        self._pulse_on = False
        self._pulse_phase = 0

        # Build UI and start serial & polling
        self.build_ui()
        self.start_serial()
        self._after_id = root.after(200, self.poll_queue)
        self._anim_id = root.after(100, self.pump_indicator_anim)

    # ---------- UI ----------
    def build_ui(self):
        # Colors
        BG = "#121212"
        PANEL = "#1E1E1E"
        ACCENT = "#4EAFFF"
        BTN = "#3A82F7"
        TEXT = "#EDEDED"
        PUMP_ON_COLOR = "#00FF8A"
        PUMP_OFF_COLOR = "#FF6B6B"

        self.root.configure(bg=BG)
        style = ttk.Style()
        try:
            style.theme_use("clam")
        except Exception:
            pass

        # Global style tweaks
        style.configure("TLabel", background=BG, foreground=TEXT, font=("Segoe UI", 10))
        style.configure("Header.TLabel", font=("Segoe UI", 12, "bold"))
        style.configure("Accent.TLabel", foreground=ACCENT)
        style.configure("Card.TFrame", background=PANEL)
        style.configure("TButton", padding=6)
        style.configure("Accent.TButton", background=BTN, foreground="white")

        main = ttk.Frame(self.root, padding=16, style="Card.TFrame")
        main.place(relx=0.5, rely=0.5, anchor="center", width=680, height=500)

        # Top row: connection + mode
        top = ttk.Frame(main, style="Card.TFrame")
        top.pack(fill="x", pady=(0, 12))
        ttk.Label(top, textvariable=self.connection_label, style="TLabel").pack(side="left", padx=(0, 12))
        ttk.Label(top, text="Mode:", style="TLabel").pack(side="left")
        mode_combo = ttk.Combobox(top, textvariable=self.mode, values=["AUTO", "MANUAL"], width=9, state="readonly")
        mode_combo.pack(side="left", padx=(6, 12))
        mode_combo.bind("<<ComboboxSelected>>", self.on_mode_change)

        # Dashboard frame (grid two columns)
        dash = ttk.Frame(main, style="Card.TFrame")
        dash.pack(fill="both", expand=True)

        # Left: Moisture big card and controls
        left = ttk.Frame(dash, style="Card.TFrame")
        left.grid(row=0, column=0, sticky="nsew", padx=(0, 8))
        dash.columnconfigure(0, weight=1)

        ttk.Label(left, text="Moisture Level", style="Header.TLabel").pack(anchor="w")
        self.moist_label = ttk.Label(left, text="0", font=("Segoe UI", 40, "bold"), foreground=ACCENT, background=PANEL)
        self.moist_label.pack(pady=(6,12))

        thr_frame = ttk.Frame(left, style="Card.TFrame")
        thr_frame.pack(fill="x", pady=(4,8))
        ttk.Label(thr_frame, text="Threshold:", style="TLabel").pack(side="left")
        thr_spin = ttk.Spinbox(thr_frame, from_=0, to=4095, textvariable=self.threshold, width=10)
        thr_spin.pack(side="left", padx=(8,10))
        send_btn = ttk.Button(thr_frame, text="Send", command=self.send_threshold)
        send_btn.pack(side="left")

        # Manual control buttons
        btn_frame = ttk.Frame(left, style="Card.TFrame")
        btn_frame.pack(fill="x", pady=(8,0))
        pump_on_btn = ttk.Button(btn_frame, text="Pump ON", command=self.pump_on)
        pump_on_btn.pack(side="left", padx=(0,8))
        pump_off_btn = ttk.Button(btn_frame, text="Pump OFF", command=self.pump_off)
        pump_off_btn.pack(side="left", padx=(0,8))
        reconnect_btn = ttk.Button(btn_frame, text="Reconnect", command=self.reconnect_serial)
        reconnect_btn.pack(side="left")

        # Right: Pump card + Log
        right = ttk.Frame(dash, style="Card.TFrame")
        right.grid(row=0, column=1, sticky="nsew", padx=(8, 0))
        dash.columnconfigure(1, weight=1)

        # Pump status card
        pump_card = ttk.Frame(right, padding=12, style="Card.TFrame")
        pump_card.pack(fill="x", pady=(0, 12))
        ttk.Label(pump_card, text="Pump Status", style="Header.TLabel").pack(anchor="w")
        # Animated pump indicator: a canvas circle + label
        self.pump_canvas = tk.Canvas(pump_card, width=80, height=80, highlightthickness=0, bg=PANEL)
        self.pump_canvas.pack(pady=(8,6))
        # draw circle center (we'll animate its color / size)
        self._pump_circle = self.pump_canvas.create_oval(10, 10, 70, 70, fill=PUMP_OFF_COLOR, outline="")
        self.pump_text = ttk.Label(pump_card, textvariable=self.pump_state, font=("Segoe UI", 14, "bold"))
        self.pump_text.pack()

        # small info
        ttk.Label(pump_card, text="Indicator pulses when pump is ON", style="TLabel").pack(pady=(6,0))

        # Log box
        log_card = ttk.LabelFrame(right, text="Log", padding=8)
        log_card.pack(fill="both", expand=True)
        self.log_text = tk.Text(log_card, height=10, width=40, bg="#0B0B0B", fg="#B9FFDA", insertbackground="white", relief="flat")
        self.log_text.pack(fill="both", expand=True)

        # quick footer
        footer = ttk.Frame(main, style="Card.TFrame")
        footer.pack(fill="x", pady=(8,0))
        ttk.Label(footer, text="ESP32 Plant Watering • Demo UI", style="TLabel").pack(side="left")

        # store colors for animation
        self._colors = {
            "pump_on": PUMP_ON_COLOR,
            "pump_off": PUMP_OFF_COLOR,
            "panel_bg": PANEL
        }

    # ---------- Serial management ----------
    def start_serial(self):
        if USE_SERIAL:
            try:
                self.serial_thread = SerialThread(self.queue, SERIAL_PORT, SERIAL_BAUD)
                self.serial_thread.start()
                self.connection_label.set(f"Serial: {SERIAL_PORT} @ {SERIAL_BAUD}")
                # send initial mode and threshold after short delay
                self.root.after(900, lambda: self.send_line(f"MODE:{self.mode.get()}"))
                self.root.after(1200, lambda: self.send_threshold())
            except Exception as e:
                self.connection_label.set("Serial not available")
                self.log(f"Serial start failed: {e}")
        else:
            self.serial_thread = SerialThread(self.queue, None, 0)
            self.serial_thread.start()
            self.connection_label.set("Mock mode (no serial)")

    def reconnect_serial(self):
        if self.serial_thread:
            self.serial_thread.stop()
        time.sleep(0.2)
        self.start_serial()
        self.log("Reconnecting serial...")

    def send_line(self, line):
        self.log(f"> {line}")
        if self.serial_thread:
            try:
                self.serial_thread.send(line)
            except Exception as e:
                self.log(f"Serial send error: {e}")

    def send_threshold(self):
        thr = self.threshold.get()
        self.send_line(f"THRESHOLD:{thr}")

    def pump_on(self):
        self.send_line("PUMP_ON")
        self.pump_state.set("ON")
        self.log("Pump ON requested")

    def pump_off(self):
        self.send_line("PUMP_OFF")
        self.pump_state.set("OFF")
        self.log("Pump OFF requested")

    def on_mode_change(self, event=None):
        mode = self.mode.get()
        self.send_line(f"MODE:{mode}")
        self.log(f"Mode set to {mode}")

    # ---------- Queue poll ----------
    def poll_queue(self):
        try:
            while True:
                line = self.queue.get_nowait()
                self.handle_line(line)
        except queue.Empty:
            pass
        self._after_id = self.root.after(200, self.poll_queue)

    def handle_line(self, line):
        self.log(f"< {line}")
        if line.startswith("MOISTURE:"):
            try:
                val = int(line.split(":", 1)[1])
                self.current_moisture.set(val)
                self.moist_label.configure(text=str(val))
            except:
                pass
        elif line.startswith("PUMP:"):
            state = line.split(":", 1)[1].upper()
            if state not in ("ON", "OFF"):
                state = "UNKNOWN"
            self.pump_state.set(state)
            # update immediate pump indicator colors (animation loop handles pulsing)
            if state == "ON":
                self._pulse_on = True
            else:
                self._pulse_on = False
                # set to static off color
                self.pump_canvas.itemconfig(self._pump_circle, fill=self._colors["pump_off"])
        else:
            # other messages: just log
            pass

    # ---------- Logging ----------
    def log(self, msg):
        ts = time.strftime("%H:%M:%S")
        self.log_text.configure(state="normal")
        self.log_text.insert("end", f"[{ts}] {msg}\n")
        self.log_text.see("end")
        self.log_text.configure(state="disabled")

    # ---------- Pump indicator animation ----------
    def pump_indicator_anim(self):
        """
        If pump ON -> pulse the circle (change size and color alpha mimic).
        If pump OFF -> ensure static off color.
        """
        try:
            if self._pulse_on:
                # create a smooth pulse based on phase
                self._pulse_phase = (self._pulse_phase + 1) % 40
                phase = self._pulse_phase / 40.0  # 0..1
                # scale between 0.95..1.15
                scale = 0.95 + 0.2 * (0.5 - abs(phase - 0.5))
                # compute new coords (centered)
                cx1, cy1, cx2, cy2 = 10, 10, 70, 70
                w = cx2 - cx1
                h = cy2 - cy1
                new_w = w * scale
                new_h = h * scale
                cx = (cx1 + cx2) / 2
                cy = (cy1 + cy2) / 2
                nx1 = cx - new_w / 2
                ny1 = cy - new_h / 2
                nx2 = cx + new_w / 2
                ny2 = cy + new_h / 2
                self.pump_canvas.coords(self._pump_circle, nx1, ny1, nx2, ny2)
                # color pulse (interpolate between bright and dim)
                # simple approach: toggle brightness using phase
                bright = int(200 + 55 * (0.5 - abs(phase - 0.5)) * 2)  # 200..255
                color = f"#{0:02x}{bright:02x}{138:02x}"  # greenish pulse (R=0,G=bright,B=138)
                self.pump_canvas.itemconfig(self._pump_circle, fill=color)
            else:
                # reset phase and static circle
                self._pulse_phase = 0
                self.pump_canvas.coords(self._pump_circle, 10, 10, 70, 70)
                self.pump_canvas.itemconfig(self._pump_circle, fill=self._colors["pump_off"])
        except Exception as e:
            # animation should never crash app
            print("Animation error:", e)
        finally:
            self._anim_id = self.root.after(60, self.pump_indicator_anim)

    # ---------- Cleanup ----------
    def close(self):
        if self.serial_thread:
            self.serial_thread.stop()
        if hasattr(self, "_after_id") and self._after_id:
            try:
                self.root.after_cancel(self._after_id)
            except:
                pass
        if hasattr(self, "_anim_id") and self._anim_id:
            try:
                self.root.after_cancel(self._anim_id)
            except:
                pass

# ---------- Run ----------
def main():
    root = tk.Tk()
    app = PlantApp(root)
    def on_closing():
        if messagebox.askokcancel("Quit", "Quit and close serial?"):
            app.close()
            root.destroy()
    root.protocol("WM_DELETE_WINDOW", on_closing)
    root.mainloop()

if __name__ == "__main__":
    main()

